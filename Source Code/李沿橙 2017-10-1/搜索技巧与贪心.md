搜索技巧与贪心

DFS

搜索树：子状态入/出栈

复杂度：最大深度，每个状态的转移数

剪枝：试图减少从每个状态可以转移到的状态数

可行性剪枝、最优化剪枝

Eg 泰国佛塔 POJ 1190
高度和半径从下往上递减，且均为正整数。
体积和层数确定，求最小表面积。

解：search(V, floors, $R_{pre}$, $H_{pre}$, S)
深度不大，分支很多
可行性剪枝：剩下的若干层都放最大的圆柱，体积也不够
最优性剪枝：剩下的若干层都放最小的圆柱，得出的表面积比当前最优解劣
剩下的体积所需的最小表面积加上当前表面积比当前最优解劣
预处理`F[R][H][M]`等数据。

记忆化搜索

时间复杂度O(m + nT)，n为状态数，T为搜索过程在每个状态本身所花费的时间

Eg 着色方案 SCOI 2008
有n个木块排成一行，有k种颜色的油漆，其中第i种颜色的油漆够涂$c_i$块木块。所有油漆刚好足够涂满所有木块。求任意两个相邻木块颜色不同的着色方案。

解：search(a, b, c, d, e, pre) ，pre代表上一个颜色，a。。。表示能涂x次的油漆有几个

迭代加深搜索
对搜索树的深度进行控制，不断增大最大深度d。

Eg 棋盘染色
一个5×5的黑白棋盘，把尽量少的白格子染成黑色，使黑格子四连通。

search（i，j，k），maxK。之前（i，j）的格子都已四连通。

中途相遇法
将搜索问题分为两个子问题，通过合并子问题的答案获取最终的答案。

Eg 求最大独立集，点数n <= 50
（这是一个NP问题）

宽度优先搜索

Eg 单源最短路
给定一张边权为0或1的图，求从起点出发到达每个点的最短路径。用BFS。

解：由边权为0的边转移过去的状态放到队首，边权为1的边转移过去的状态放到队尾即可。
原因是BFS的原理：在队列中相同层的状态是连续的。

Eg 给定一张DAG，确定每个点的拓扑序

解：Kahn算法

贪心算法

Eg 给定一张n个点的图，求单源最短路
对于每个点有在$t_i$时间不能到达的限制。$n\,\le\,100000$。

解：max(dis[i], t[i])跑Dijkstra

Eg 荷马史诗 NOI 2015
K叉Huffman编码问题
还要判断深度